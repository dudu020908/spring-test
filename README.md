# 실시간 온라인 메모장 프로젝트
  Redis + MySQL + GraphQL + SpringBoot 기반의 실시간 온라인 메모장
## 프로젝트 개요
- 실시간 온라인 동기화 서비스
- 여러 사용자의 실시간 변경사항을 Redis Pub/Sub를 통해 구현합니다.
- GraphQL을 사용하여 데이터를 검색 및 업데이트를 지원합니다.
- TDD(Test Driven Development)를 기반으로 작성되어 안정적인 기능을 구현합니다.
- Jira를 사용하여 이슈를 관리합니다.
## 사용기술 스택
| 분류 | 기술 |
|---------------|------|
| Backend | Spring Boot, GraphQL |
| Frontend | React |
| Database | MySQL |
| 실시간 처리 | Redis (Pub/ Sub) |
| 인증/보안 | JWT |
| 프로젝트 관리 | 지라 |
| 협업/ 버전 관리 | Git, GitHub |
---
## 시스템 아키텍처
1. 클라이언트 요청
사용자는 GraphQL API를 통해 메모장 생성, 수정/삭제와 같은 요청을 서버로 전송합니다.

2. Spring Boot + GraphQL
쿼리문 처리, 데이터베이스 또는 캐시 계층에 대한 적절한 서비스 로직을 통해 액세스합니다.
GraphQL Query/Mutation을 통해 필요한 데이터만 골라내 처리합니다.

3. MySQL
MySQL에 저장된 데이터는 영구적으로 저장됩니다.
GraphQL Resolver는 필요한 데이터만 정교히 처리하며 인덱싱된 컬럼을 기반으로 빠르게 작동합니다.

4. Redis Pub/Sub
메모를 수정하면 Redis가 그 내용을 다른 사용자에게 실시간으로 알려주고,
같은시각 같은 메모장을 보던 다른 사용자는 Redis Subscribe 채널을 통해 실시간 메시지를 수신하고, 실시간으로 UI가 업데이트되어 확인합니다.

5. 클라이언트 UI 동기화
변경된 메모장 내용은 자동으로 반영되어 새로고침 할 필요 없이 실시간으로 사용할 수 있습니다.

## 기술별 사용 이유 및 구조 설계
1.React
- 사용 이유: React는 페이지 전체를 새로 고침하지 않고도 화면을 빠르게 변경할 수 있는 SPA방식으로, 메모장 서비스에서 화면 전환 속도와 동적 UI 설정이 중요했기 때문에 채택되었습니다.
- 구조 설계: 클라이언트 단에 있는 CRUD의 모든 인터페이스를 구성하고, GraphQL API와 WebSocket을 통해 실시간으로 데이터에 연결하며, React Router를 사용하여 URL에 따라 페이지 상태를 유지합니다.
  
2.NGINX
 - 사용이유 : React로 빌드된 정적 파일(HTML/CSS/JS)을 빠르고 안정적으로 서비스하고 클라이언트에서 오는 API 요청을 Spring Boot 서버로 프록시(중간 전달) 하기 위해 채택했습니다.
 - 구조설계 : 정적 파일은 / 루트 요청에 대응 /api, /graphql, /ws 요청은 백엔드로 프록시 처리
   
3.Spring Boot (GraphQL + WebSocket + 인증)
 - 사용이유 : GraphQL을 통해 효율적인 데이터 CRUD를 구현하고 WebSocket으로 실시간 메모 동기화 기능을 처리함으로써 주요 기능을 쉽게 통합할 수 있으며, 저희가 사용해본 경험이 있어 빠른개발이 가능할것같아 채택하였습니다.
 - 구조설계 : /graphql 요청은 GraphQL 핸들러로 연결되어 메모장 데이터를 처리하고, WebSocket 엔드포인트를 통해 실시간 알림 및 공동 편집 처리. 사용자 로그인 상태는 토큰 기반으로 인증 관리
 - GraphQL API 예시 메모 목록 조회시                 WebSocket 메시지 구조
   query {                                          {
    memos {                                          "type": "memo_update",
    id                                               "memoId": 12,
    content                                          "content": "최신 내용",
    updatedAt                                        "updatedBy": "user123"
  }                                                 }
}

4.Redis (Pub/Sub + 캐시)
- 사용 이유: 여러 사용자가 동시에 메모를 수정할 때, Redis의 Pub/Sub 구조를 사용하여 실시간으로 공유하고 자주 보는 데이터를 스캔하여 서버 부하와 속도를 줄일 수 있습니다.
 - 구조설계 : 메모 수정 시 Redis 채널에 Publish WebSocket으로 연결된 사용자들은 Redis를 통해 수신한 내용을 즉시 화면에 반영 특정 사용자 정보나 라벨 목록 등은 캐싱하여 조회 속도 개선
   
5. MySQL (사용자, 메모, 라벨 저장소)
 - 사용이유 : 데이터 무결성과 트랜잭션 처리에 강점이 있고, 사용해본 경험이 있어 채택하게 되었습니다.
 - 구조설계 : 외래키로 메모와 사용자 연결, 메모-라벨 다대다 관계 구현 및 변경 시점 기록을 위한 revision 또는 history 테이블 확장 가능
   
6.MinIO
 - 사용이유 : 메모에 이미지나 파일을 첨부할 수 있는 기능을 제공하기 위해 파일 저장소가 필요했고, MinIO는 AWS S3와 호환되는 자체 구축형 객체 스토리지로, 사내 혹은 로컬 환경에서도 활용 가능하여 채택되었습니다.
 - 구조설계 : 사용자가 파일 업로드 -> Spring 서버에서 MinIO로 저장 요청 -> 저장된 파일 경로(URL)는 MySQL의 메모 테이블에 기록 -> 미리보기나 다운로드 시 해당 URL을 통해 직접 접근

## 역할 분담 내용 

이도원 (팀장 / 백엔드 QA)
역할
- 백엔드 전반 아키텍처 관리
- 코드 품질(QA) 책임자
주요업무
- GraphQL API + 로그인 서버
- MySQL DB 설계 및 검증
- Redis Pub/Sub 실시간 로직 QA
- 테스트 계획 수립 및 코드 리뷰
  
김찬규 (백엔드)
역할
- 실시간 동기화 로직 구현
- 첨부파일 저장/검증 담당
주요업무
- Redis Pub/Sub 기반 알림/캐시 로직 구현
- WebSocket 서버 연결 구현
- MinIO 파일 업로드·다운로드·메타데이터 검증 로직 개발
- QA 가이드에 따른 코드 수정 및 테스트 케이스 보완
  
염재현 (프론트엔드, 인프라 개발)
역할
- UI 개발
- 배포,운영 담당
주요업무
- React 프론트엔드 개발
- NGINX 설정 & 배포 파이프라인
- CI/CD 구성 & 모니터링
- QA 지원
  
팀장(이도원)은 QA 관점에서 전체 백엔드를 검증하고 이끌어가며, 
김찬규는 백엔드 기능을 구현·보완, 
염재현은 프론트엔드 개발과 배포/운영을 책임집니다.
## 문제 상황 및 해결 내용 (트러블 슈팅 사례 포함)
### 문제상황
아키텍처 설계 초기 단계에서 메모장을 만들면 메모 데이터를 어디에 저장하고 어떤 방식으로 불러올지를 두고 이해가 되지않아 혼란이 있었습니다.
디스크와 인메모리 모두 사용하는 구조를 전제로 설계하고 있었지만, 어떤방식으로 작동하는지, 어떻게 넣어야할지 어려웠지만, 여러 논의를 거친결과
- Redis는 빠르지만 휘발성이라 영속 저장에는 적합하지 않음
- MySQL은 안전하지만 실시간 반영에는 상대적으로 느림
실시간 메모 편집 기능은 즉시 반응해야 하고, 동시에 데이터는 저장되어야 하므로 두 저장소를 모두 사용하기로 하였고, 역할을 아래와같이 하게되었다.
  - MySQL : 메모, 사용자, 라벨 등의 영구 저장용으로 사용
  - Redis : 실시간 편집 이벤트 전파 (Pub/Sub),자주 조회되는 라벨 목록 등 일시적 캐시용으로만 사용
해당 역할을 분담하고 흐름도는
1. 클라이언트가 메모를 수정하면 → 서버가 MySQL에 먼저 저장
2. 저장 완료 후, 해당 이벤트를 Redis 채널에 Publish
3. 사용자 WebSocket을 통해 변경사항 수신 및 반영
그 결과, 실시간성과 영속성을 둘다 보장하고, 깔끔한 실시간 메모장 시스템 아키텍처링이 가능해졌다.
### 문제상황2
처음엔 실시간 메모장 동기화를 구현하는 방식에 있어 HTTP기반으로 주기적으로 요청하는 방식을 생각하였으나
사용자가 동시에 여러 명 접속하면 서버에 주기적으로 요청이 폭주할 수 있고, 실시간 반영이아닌 수초 이상의 지연이 발생할 수 있어 실시간성이 떨어진다는 피드백을 받고
해당 방식을 WebSocket 기반 구조로 전환하여 클라이언트가 WebSocket을 통해 서버에 연결하게될경우,
해당 세션을 유지하면서 실시간으로 변경된 메시지를 전달받아
서버가 Redis Pub/sub 를 통해 이벤트를 수신하게되면 사용자에게 전달하여 클라이언트가 즉시 반영하는식으로 바꾸게 되었습니다.
그 결과 서버 부하는 안정되고, 실시간성도 올라가게되었습니다.
